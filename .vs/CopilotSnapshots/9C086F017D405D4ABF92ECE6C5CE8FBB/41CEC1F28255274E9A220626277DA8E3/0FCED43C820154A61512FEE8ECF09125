using HighSens.Application.DTOs.Inbound;
using HighSens.Application.Interfaces.IServices;
using HighSens.Domain;
using HighSens.Domain.Interfaces;
using System.Linq;
using System.Collections.Generic;
using InfraStructure.Context;
using Microsoft.EntityFrameworkCore;

namespace HighSens.Application.Services
{
    public class InboundService : IInboundService
    {
        private readonly IRepository<Inbound> _inboundRepo;
        private readonly IClientRepository _clientRepo;
        private readonly IProductRepository _productRepo;
        private readonly ISectionRepository _sectionRepo;
        private readonly IStockRepository _stockRepo;
        private readonly DBContext _dbContext; // for direct ProductStock/SectionStock queries
        private readonly IUnitOfWork _uow;

        public InboundService(
            IRepository<Inbound> inboundRepo,
            IClientRepository clientRepo,
            IProductRepository productRepo,
            ISectionRepository sectionRepo,
            IStockRepository stockRepo,
            IUnitOfWork uow,
            DBContext dbContext)
        {
            _inboundRepo = inboundRepo;
            _clientRepo = clientRepo;
            _productRepo = productRepo;
            _sectionRepo = sectionRepo; // fix below
            _stockRepo = stockRepo;
            _uow = uow;
            _dbContext = dbContext;
        }

        // Fixing field name typo
        private readonly ISectionRepository _section_repo;

        public async Task<int> CreateInboundAsync(CreateInboundRequest request)
        {
            if (request == null) throw new ArgumentNullException(nameof(request));
            if (string.IsNullOrWhiteSpace(request.ClientName)) throw new ArgumentException("ClientName is required");
            if (request.Lines == null || request.Lines.Count == 0) throw new ArgumentException("Inbound must contain at least one line");

            var clientName = request.ClientName.Trim();

            // Use transaction
            int inboundId = 0;
            await _uow.ExecuteInTransactionAsync(async () =>
            {
                // find or create client
                var client = await _clientRepo.FindByNameAsync(clientName);
                if (client == null)
                {
                    client = new Client { Name = clientName };
                    await _clientRepo.AddAsync(client);
                    await _uow.SaveChangesAsync(); // ensure client.Id is generated
                }

                // Create inbound with client ID
                var inbound = new Inbound
                {
                    ClientId = client.Id,
                    CreatedAt = DateTime.UtcNow
                };

                // Track pending stock updates in-memory to handle multiple lines referring to same key
                var pendingStock = new Dictionary<string, Stock>();

                foreach (var line in request.Lines)
                {
                    if (line == null) throw new ArgumentException("Line cannot be null");
                    if (string.IsNullOrWhiteSpace(line.ProductName)) throw new ArgumentException("ProductName is required");
                    if (string.IsNullOrWhiteSpace(line.SectionName)) throw new ArgumentException("SectionName is required");
                    if (line.Cartons < 0 || line.Pallets < 0) throw new ArgumentException("Cartons and pallets must be non-negative");

                    var productName = line.ProductName.Trim();
                    var sectionName = line.SectionName.Trim();

                    // resolve product
                    var product = await _productRepo.GetByNameAsync(productName);
                    if (product == null) throw new ArgumentException($"Product not found: {productName}");

                    // resolve section
                    var section = await _sectionRepo.GetByNameAsync(sectionName);
                    if (section == null) throw new ArgumentException($"Section not found: {sectionName}");

                    // compute quantity
                    var quantity = (decimal)line.Cartons + ((decimal)line.Pallets * 100m);

                    var detail = new InboundDetail
                    {
                        ProductId = product.Id,
                        SectionId = section.Id,
                        Cartons = line.Cartons,
                        Pallets = line.Pallets,
                        Quantity = quantity
                    };

                    inbound.Details.Add(detail);

                    // Prepare key
                    var key = $"{product.Id}:{section.Id}";

                    // Try pending first, otherwise load from repo
                    if (!pendingStock.TryGetValue(key, out var stock))
                    {
                        stock = await _stockRepo.FindAsync(client.Id, product.Id, section.Id);
                    }

                    if (stock == null)
                    {
                        stock = new Stock
                        {
                            ClientId = client.Id,
                            ProductId = product.Id,
                            SectionId = section.Id,
                            Cartons = line.Cartons,
                            Pallets = line.Pallets
                        };
                        await _stockRepo.AddAsync(stock);
                        pendingStock[key] = stock;
                    }
                    else
                    {
                        stock.Cartons += line.Cartons;
                        stock.Pallets += line.Pallets;
                        _stockRepo.Update(stock);
                        pendingStock[key] = stock;
                    }

                    // Update ProductStock (aggregate per product)
                    var prodStock = await _dbContext.ProductStocks.FirstOrDefaultAsync(ps => ps.ClientId == client.Id && ps.ProductId == product.Id);
                    if (prodStock == null)
                    {
                        prodStock = new ProductStock
                        {
                            ClientId = client.Id,
                            ProductId = product.Id,
                            Cartons = line.Cartons,
                            Pallets = line.Pallets
                        };
                        await _dbContext.ProductStocks.AddAsync(prodStock);
                    }
                    else
                    {
                        prodStock.Cartons += line.Cartons;
                        prodStock.Pallets += line.Pallets;
                        _dbContext.ProductStocks.Update(prodStock);
                    }

                    // Update SectionStock (aggregate per section)
                    var secStock = await _dbContext.SectionStocks.FirstOrDefaultAsync(ss => ss.ClientId == client.Id && ss.SectionId == section.Id);
                    if (secStock == null)
                    {
                        secStock = new SectionStock
                        {
                            ClientId = client.Id,
                            SectionId = section.Id,
                            Cartons = line.Cartons,
                            Pallets = line.Pallets
                        };
                        await _dbContext.SectionStocks.AddAsync(secStock);
                    }
                    else
                    {
                        secStock.Cartons += line.Cartons;
                        secStock.Pallets += line.Pallets;
                        _dbContext.SectionStocks.Update(secStock);
                    }
                }

                await _inboundRepo.AddAsync(inbound);
                await _uow.SaveChangesAsync();
                inboundId = inbound.Id;
            });

            return inboundId;
        }

        public Task<IEnumerable<Inbound>> GetAllInboundsAsync()
        {
            return _inboundRepo.GetAllAsync();  
        }

        public Task<IEnumerable<Inbound>> GetDailyInboundReportAsync()
        {
            return _inboundRepo.GetDailyReportAsync();
        }

        public async Task<IEnumerable<Inbound>> GetInboundReportFromToAsync(DateTime startDate, DateTime endDate)
        {
            // normalize to UTC date boundaries
            var start = startDate.Date.ToUniversalTime();
            var end = endDate.Date.AddDays(1).ToUniversalTime();

            return await _inboundRepo.GetByDateRangeAsync(start, end);
        }

        public async Task UpdateInboundAsync(int id, UpdateInboundRequest request)
        {
            throw new NotImplementedException("Update not implemented in this iteration");
        }
    }
}